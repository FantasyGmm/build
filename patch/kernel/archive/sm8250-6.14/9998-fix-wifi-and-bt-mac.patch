From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: John Doe <john.doe@somewhere.on.planet>
Date: Wed, 16 Apr 2025 08:27:28 +0000
Subject: Patching kernel sm8250 files drivers/bluetooth/btqca.c
 drivers/net/wireless/ath/ath11k/mac.c drivers/soc/qcom/socinfo.c

Signed-off-by: John Doe <john.doe@somewhere.on.planet>
---
 drivers/bluetooth/btqca.c             | 100 ++++++++-
 drivers/net/wireless/ath/ath11k/mac.c | 109 +++++++++-
 drivers/soc/qcom/socinfo.c            |  10 +
 3 files changed, 207 insertions(+), 12 deletions(-)

diff --git a/drivers/bluetooth/btqca.c b/drivers/bluetooth/btqca.c
index cdf09d9a9..d5c4a3ac5 100644
--- a/drivers/bluetooth/btqca.c
+++ b/drivers/bluetooth/btqca.c
@@ -11,10 +11,82 @@
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 
 #include "btqca.h"
 
+extern const char *qcom_serial_number;
+
+/* Define a static, predefined BD_ADDR structure */
+static const bdaddr_t static_bdaddr = {
+	.b = { 0x00, 0x03, 0x7F, 0x33, 0x22, 0x11 }
+};
+
+/**
+ * generate_bdaddr_from_serial - Generates a BD_ADDR using the serial number
+ * @bdaddr: Pointer to bdaddr_t structure to populate
+ *
+ * This function sets the first 3 bytes to 00:03:7F and the last 3 bytes
+ * are derived from the last 6 characters of qcom_serial_number in reversed order.
+ *
+ * Returns 0 on success, negative error code on failure.
+ */
+static int generate_bdaddr_from_serial(struct hci_dev *hdev, bdaddr_t *bdaddr)
+{
+	size_t serial_len;
+	const char *serial = qcom_serial_number;
+	char last6[7] = {0}; // 6 characters + null terminator
+	int i;
+	int ret;
+
+	if (!serial) {
+		bt_dev_err(hdev, "qcom_serial_number is NULL");
+		return -EINVAL;
+	}
+
+	serial_len = strlen(serial);
+	if (serial_len < 6) {
+		bt_dev_err(hdev, "qcom_serial_number is too short: %zu characters", serial_len);
+		return -EINVAL;
+	}
+
+	// Extract the last 6 characters
+	strncpy(last6, serial + serial_len - 6, 6);
+
+	// Initialize the first 3 bytes
+	bdaddr->b[5] = 0x00;
+	bdaddr->b[4] = 0x03;
+	bdaddr->b[3] = 0x7F;
+
+	// Convert the last 6 characters into 3 bytes in reversed order
+	for (i = 0; i < 3; i++) {
+		char byte_str[3] = {0};
+		u8 byte_val;
+
+		byte_str[0] = last6[i * 2];
+		byte_str[1] = last6[i * 2 + 1];
+
+		if (!isxdigit(byte_str[0]) || !isxdigit(byte_str[1])) {
+			bt_dev_err(hdev, "Invalid hex characters in serial number: %c%c",
+					   byte_str[0], byte_str[1]);
+			return -EINVAL;
+		}
+
+		ret = kstrtou8(byte_str, 16, &byte_val);
+		if (ret < 0) {
+			bt_dev_err(hdev, "Failed to convert hex string to u8: %c%c",
+					   byte_str[0], byte_str[1]);
+			return ret;
+		}
+
+		bdaddr->b[i] = byte_val; // Assign to bytes 0,1,2 (reversed order)
+	}
+
+	bt_dev_info(hdev, "Generated BD_ADDR: %pMR", bdaddr);
+
+	return 0;
+}
+
 int qca_read_soc_version(struct hci_dev *hdev, struct qca_btsoc_version *ver,
 			 enum qca_btsoc_type soc_type)
 {
 	struct sk_buff *skb;
 	struct edl_event_hdr *edl;
@@ -712,11 +784,11 @@ int qca_set_bdaddr_rome(struct hci_dev *hdev, const bdaddr_t *bdaddr)
 
 	return 0;
 }
 EXPORT_SYMBOL_GPL(qca_set_bdaddr_rome);
 
-static int qca_check_bdaddr(struct hci_dev *hdev, const struct qca_fw_config *config)
+static int __maybe_unused qca_check_bdaddr(struct hci_dev *hdev, const struct qca_fw_config *config)
 {
 	struct hci_rp_read_bd_addr *bda;
 	struct sk_buff *skb;
 	int err;
 
@@ -787,10 +859,11 @@ int qca_uart_setup(struct hci_dev *hdev, uint8_t baudrate,
 	struct qca_fw_config config = {};
 	int err;
 	u8 rom_ver = 0;
 	u32 soc_ver;
 	u16 boardid = 0;
+	bdaddr_t generated_bdaddr;
 
 	bt_dev_dbg(hdev, "QCA setup on UART");
 
 	soc_ver = get_soc_ver(ver.soc_id, ver.rom_ver);
 
@@ -978,13 +1051,34 @@ int qca_uart_setup(struct hci_dev *hdev, uint8_t baudrate,
 		break;
 	default:
 		break;
 	}
 
-	err = qca_check_bdaddr(hdev, &config);
-	if (err)
+	/* Generate BD_ADDR from qcom_serial_number */
+	err = generate_bdaddr_from_serial(hdev, &generated_bdaddr);
+	if (err) {
+		bt_dev_err(hdev, "Failed to generate BD_ADDR from serial number");
+		return err;
+	}
+
+	/* Set the generated BD_ADDR */
+	err = qca_set_bdaddr(hdev, &generated_bdaddr);
+	if (err) {
+		bt_dev_err(hdev, "Failed to set the generated BD_ADDR from serial number");
 		return err;
+	}
+
+	/* Update hdev->public_addr and hdev->bdaddr */
+	bacpy(&hdev->public_addr, &generated_bdaddr);
+	bacpy(&hdev->bdaddr, &generated_bdaddr);
+	bt_dev_info(hdev, "BD_ADDR set to %pMR", &hdev->public_addr);
+
+
+	/* Disable reading BD_ADDR from NVM */
+	//err = qca_check_bdaddr(hdev, &config);
+	//if (err)
+	//	return err;
 
 	bt_dev_info(hdev, "QCA setup on UART is completed");
 
 	return 0;
 }
diff --git a/drivers/net/wireless/ath/ath11k/mac.c b/drivers/net/wireless/ath/ath11k/mac.c
index 1298a3190..c451299d6 100644
--- a/drivers/net/wireless/ath/ath11k/mac.c
+++ b/drivers/net/wireless/ath/ath11k/mac.c
@@ -163,10 +163,95 @@ static const struct ieee80211_channel ath11k_6ghz_channels[] = {
 
 	/* new addition in IEEE Std 802.11ax-2021 */
 	CHAN6G(2, 5935, 0),
 };
 
+extern const char *qcom_serial_number;
+
+/* Define a small struct for storing a 6-byte MAC address array */
+struct macaddr_t {
+	u8 b[ETH_ALEN];
+};
+
+/* Define a static, predefined MAC_ADDR structure */
+static const struct macaddr_t static_macaddr = {
+	.b = { 0x00, 0x03, 0x7F, 0x11, 0x22, 0x33 }
+};
+
+/**
+ * generate_macaddr_from_serial - Generates a MAC_ADDR using the serial number
+ * @macaddr: Pointer to macaddr_t structure to populate
+ *
+ * This function sets the first 3 bytes to 00:03:7F and the last 3 bytes
+ * are derived from the last 6 characters of qcom_serial_number.
+ *
+ * Returns 0 on success, negative error code on failure.
+ */
+static int generate_macaddr_from_serial(struct ath11k *ar, struct macaddr_t *macaddr)
+{
+	size_t serial_len;
+	const char *serial = qcom_serial_number;
+	char last6[7] = {0}; // 6 characters + null terminator
+	int i;
+	int ret;
+
+	if (!serial) {
+		ath11k_err(ar->ab, "qcom_serial_number is NULL");
+		return -EINVAL;
+	}
+
+	serial_len = strlen(serial);
+	if (serial_len < 6) {
+		ath11k_err(ar->ab, "qcom_serial_number is too short: %zu characters", serial_len);
+		return -EINVAL;
+	}
+
+	// Extract the last 6 characters
+	strncpy(last6, serial + serial_len - 6, 6);
+
+	// Initialize the first 3 bytes
+	macaddr->b[5] = 0x00;
+	macaddr->b[4] = 0x03;
+	macaddr->b[3] = 0x7F;
+
+	// Convert the last 6 characters into 3 bytes
+	for (i = 0; i < 3; i++) {
+		char byte_str[3] = {0};
+		u8 byte_val;
+
+		byte_str[0] = last6[i * 2];
+		byte_str[1] = last6[i * 2 + 1];
+
+		if (!isxdigit(byte_str[0]) || !isxdigit(byte_str[1])) {
+			ath11k_err(ar->ab, "Invalid hex characters in serial number: %c%c",
+					   byte_str[0], byte_str[1]);
+			return -EINVAL;
+		}
+
+		ret = kstrtou8(byte_str, 16, &byte_val);
+		if (ret < 0) {
+			ath11k_err(ar->ab, "Failed to convert hex string to u8: %c%c",
+					   byte_str[0], byte_str[1]);
+			return ret;
+		}
+
+		macaddr->b[2 - i] = byte_val; // Assign to bytes 2,1,0
+	}
+
+	ath11k_info(ar->ab, "Generated MAC_ADDR: %pMR", macaddr);
+
+	return 0;
+}
+
+static void ath11k_reverse_mac(u8 *dst, const u8 *src)
+{
+	int i;
+
+	for (i = 0; i < ETH_ALEN; i++)
+		dst[i] = src[ETH_ALEN - 1 - i];
+}
+
 static struct ieee80211_rate ath11k_legacy_rates[] = {
 	{ .bitrate = 10,
 	  .hw_value = ATH11K_HW_RATE_CCK_LP_1M },
 	{ .bitrate = 20,
 	  .hw_value = ATH11K_HW_RATE_CCK_LP_2M,
@@ -10305,10 +10390,11 @@ int ath11k_mac_register(struct ath11k_base *ab)
 	struct ath11k *ar;
 	struct ath11k_pdev *pdev;
 	int i;
 	int ret;
 	u8 mac_addr[ETH_ALEN] = {0};
+	struct macaddr_t generated_macaddr;
 
 	if (test_bit(ATH11K_FLAG_REGISTERED, &ab->dev_flags))
 		return 0;
 
 	/* Initialize channel counters frequency value in hertz */
@@ -10317,23 +10403,28 @@ int ath11k_mac_register(struct ath11k_base *ab)
 
 	ret = ath11k_peer_rhash_tbl_init(ab);
 	if (ret)
 		return ret;
 
-	device_get_mac_address(ab->dev, mac_addr);
-
 	for (i = 0; i < ab->num_radios; i++) {
 		pdev = &ab->pdevs[i];
 		ar = pdev->ar;
-		if (ab->pdevs_macaddr_valid) {
-			ether_addr_copy(ar->mac_addr, pdev->mac_addr);
+
+		ret = generate_macaddr_from_serial(ar, &generated_macaddr);
+		if (ret) {
+			if (ab->pdevs_macaddr_valid) {
+				ether_addr_copy(ar->mac_addr, pdev->mac_addr);
+			} else {
+				if (is_zero_ether_addr(mac_addr))
+					ether_addr_copy(ar->mac_addr, ab->mac_addr);
+				else
+					ether_addr_copy(ar->mac_addr, mac_addr);
+				ar->mac_addr[4] += i;
+			}
 		} else {
-			if (is_zero_ether_addr(mac_addr))
-				ether_addr_copy(ar->mac_addr, ab->mac_addr);
-			else
-				ether_addr_copy(ar->mac_addr, mac_addr);
-			ar->mac_addr[4] += i;
+			ath11k_reverse_mac(ar->mac_addr, generated_macaddr.b);
+			ath11k_info(ab, "MAC_ADDR set to %pMR", generated_macaddr.b);
 		}
 
 		idr_init(&ar->txmgmt_idr);
 		spin_lock_init(&ar->txmgmt_idr_lock);
 
diff --git a/drivers/soc/qcom/socinfo.c b/drivers/soc/qcom/socinfo.c
index 18d7f1be9..822e159b5 100644
--- a/drivers/soc/qcom/socinfo.c
+++ b/drivers/soc/qcom/socinfo.c
@@ -161,10 +161,14 @@ struct smem_image_version {
 	char pad;
 	char oem[SMEM_IMAGE_VERSION_OEM_SIZE];
 };
 #endif /* CONFIG_DEBUG_FS */
 
+/* Global variable to hold the serial number */
+const char *qcom_serial_number;
+EXPORT_SYMBOL(qcom_serial_number);
+
 struct qcom_socinfo {
 	struct soc_device *soc_dev;
 	struct soc_device_attribute attr;
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *dbg_root;
@@ -801,10 +805,13 @@ static int qcom_socinfo_probe(struct platform_device *pdev)
 		qs->attr.serial_number = devm_kasprintf(&pdev->dev, GFP_KERNEL,
 							"%u",
 							le32_to_cpu(info->serial_num));
 		if (!qs->attr.serial_number)
 			return -ENOMEM;
+
+		/* Assign the serial number to the global variable */
+		qcom_serial_number = qs->attr.serial_number;
 	}
 
 	qs->soc_dev = soc_device_register(&qs->attr);
 	if (IS_ERR(qs->soc_dev))
 		return PTR_ERR(qs->soc_dev);
@@ -824,10 +831,13 @@ static void qcom_socinfo_remove(struct platform_device *pdev)
 	struct qcom_socinfo *qs = platform_get_drvdata(pdev);
 
 	soc_device_unregister(qs->soc_dev);
 
 	socinfo_debugfs_exit(qs);
+
+	/* Clear the global serial number */
+	qcom_serial_number = NULL;
 }
 
 static struct platform_driver qcom_socinfo_driver = {
 	.probe = qcom_socinfo_probe,
 	.remove = qcom_socinfo_remove,
-- 
Created with Armbian build tools https://github.com/armbian/build

